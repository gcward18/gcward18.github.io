<!-- Latest compiled and minified CSS -->
<head>
    <link href="css/shCore.css" rel="stylesheet" type="text/css" />
    <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
</head>
 <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
<div class="jumbotron text-center">
        <h1>Move Semantics</h1>
</div>

<div name="slide">
    <h2>The Goal</h2>
    <p>fast code. One big problem is the generation of temporary objects. Consider:</p>
    <pre  class='brush: cpp'>
        Array squares(const Array& s)
        {
            int n = s.getSize();
            Array sq_array(n);

            for(int i = 0; i < n; i++)
            {
                sq_array[i] = s[i]*s[i];
            }
            return sq_array;
        }
    </pre>
    <pre  class='brush: cpp'>
        int main()
        {
            Array stuff[1000];
            // stuff
            stuff = squares(stuff);
            // more stuff
        }
    </pre>
    <p>What's the problem? <b>Copies</b> - so many copies of arrays</p>
    <p>Many of the copies are temp objects that just get tossed. It would be nice if we could use them. 
        The difficulty is that we (compiler) had no way to identify temp objects. <b>In C++11, we do.</b>
    </p>
</div>
<div>
    <h2>rvalues vs. lvalues</h2>
    <p>An <b>lvlaue</b> (formerly left-hand value) is an expression whith a locatable memory - a locator value.
    It has some permanent piece of memory</p>

    <h3>Example 1</h3>
    <pre  class='brush: cpp'>
        int x;
        x = 10; // an lvalue
    </pre>
    <h3>Example 2</h3>
    <pre  class='brush: cpp'>
        int x;
        int& getX() {return x;}
        getX() = 10; //an lvalue that is not a variable
    </pre>

    <p>An <b>rvalue</b> is an expression taht gives a temporary object</p>
    <h3>Example 1</h3>
    <pre  class='brush: cpp'>
        int x;
        int getX() { return 4; }
        getX(); // a tempoarry obj - an rvalue
        x = getX();
    </pre>
    <p>Can we identify temp objects? In C++03 (or before), answer is no. A <b>rvalue reference</b> is a
    reference that will only bind to a temparary object.</p>
    <h3>Example Pre C++03</h3>
    <pre  class='brush: cpp'>
        const int& z = getX(); // ok
        int &z = getX(); // NOT ok
    </pre>

    <p> So, an rvalue reference can "detect" temp objects.</p>
    <p>Now, consider these two functions : </p>
    <ol>
        <li><pre  class='brush: cpp'>
            void printref( const string &s) { cout << s; }
        </pre></li>
        <li><pre  class='brush: cpp'>
            void printref(string &&s) { cout << s; }
        </pre></li>
    </ol>
    <p> 
        function #1 will accept any argument (mutable or not) lvalue or rvalue 
        if function #2 is not presetn. But if Function #2 is present, Function #1 
        will accept all <b>except</b> mutable rvalue references.
    </p>
</div>

<div>
    <h2><b>Move Constructors</b></h2>
    <p>Like a copy constuctor, a move constructor builds a new object from an old one. But, rather than create new memory, it will "move" 
        the object. It can (do that) because it knows the arugment is a temporary object.an rvalue reference. If the argument is a primative,
        then it simply makes a copy. But if the object to copy has/is a ptr, it will steal the ptr and nullify the ptr to the old object. 
        The old object won't need taht ptr because it's about to go away. 
    </p>
    <pre class='brush: cpp'>
        class Array
        {
            public:
                Array(Array&& src): ptr_to_data(src.ptr_to_data),size(src.size)
                {
                    src.ptr_to_data = nullptr;
                    src.size = 0;
                }
        };
    </pre>
    <p>
        Why set src ptr to nullptr? We set the src's ptr to nullptr because other is a temp obj. about to go away and when it does, 
        it calls it's destructor which will delete the ptr. Hence, we get no crash later.
    </p>
    <p>
        Now, suppose that there is a member of the class that is an object (that is not a primative). Suppose we have a class like so....
    </p>

    <pre class='brush: cpp'>
        class Data
        {
            private:
                string name;
                int size;
            public:
                Data(const int size, const string &name);  // sets the name and size
                Data(const Data &src) : size(src.size), name(src.name) {}
                Data(cosnt Data &&src) : size(src.size), name(src.size)
        };
    </pre>

    <pre class='brush: cpp'>
        class Array
        {
            private:
                float *ptr_to_data;
                Data m_size_n_name;
            public:
                // stuff
        };
    </pre>
    <p>Will our move constructor for the Array class work? <b>NO....</b></p>
    <p>We need to do the following:</p>

    <pre class='brush: cpp'>
        #include "<"utility> // for std::utility

        Array(Array &&src) :ptr_to_data(src.ptr_to_data),
                            m_size_n_name(std::move(src.m_size_n_name))
                            { 
                                src.m_size_n_name = nullptr;
                            }
    </pre>
    <p>... And we have to do the same for class Data.</p>
    <h3>The Reason:</h3>
    <p> the "src" in Array's move constructor (the arguement) is an rvalue reference. But, here that rvalue
        reference isn't an rvalue it's an lvalue. It's scope is a new scope where that rvalue reference is 
        (semi)permanent - a lvalue.  So we have to use std::move to accomplish the task. How does that happen?
        Big mystery.... it cast's it. 
    </p>
</div>