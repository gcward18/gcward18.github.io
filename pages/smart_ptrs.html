<!-- Latest compiled and minified CSS -->
<head>
        <link href="css/shCore.css" rel="stylesheet" type="text/css" />
        <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
    </head>
     <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
    <div class="jumbotron text-center">
            <h1>Smart Pointers</h1>
    </div>
    
    <div name="slide">
        <h2>Pointers are very necessary in robust c++ coding. But, the built-in ptrs are too weak and too strong. They give 
            the programmer too much freedom to screw up. It's too easy to make <b>fatal</b> mistakes
        </h2>
        <p><b>Aggregation</b> is the combining of objects inside other objects. In doing so, you must be aware of memory management
             concerns/dangers/issues/problmes/etc.If a ptr is contained, who controls the lifteime of the lifetime of the object 
             this is pointed to. When a built-in ptr is a member variable of an object, it is called "referentail aggregation". 
             (sometimes referred to "referential aggrevation"). Because of default copy behavior, when an aggregate is copied what is 
             is getting copied? The pointer is getting copied, but not that too which the pointer points. Leaks cause in many ways, but 
             they can be created in anti-ninjamanic ways.
        </p>

        <p>Example: when an exception is thrown</p>

        <p>Good programmers will define ptr objects that act as smart pointers. They intercept indirection and perform the necessary
            housekeeping to prevent leaks. We write smart pointers to establish a one-to-one relationship between ptr and object.
        </p>

        <p>We'll create two classes: The copy builtin ptr class, and extend that for the copied object class.</p>

        <pre  class='brush: cpp'>
            template "<"typename T>
            class CBPtr     //copied built-in ptr
            {
                public:
                    CBPtr(): the_ptr(0) {} // defaults to null
                    
                    CBPtr(T* just_created): the_ptr(just_created) {}
                    
                    ~CBPtr() { delete the_ptr; }
                    
                    CBPtr(const CBPtr"<"T> &aCP): the_ptr(aCP.isNull()? 0 : new(*aCP.the_ptr)) {}
                    
                    CBPtr"<"T> & operator =(T *p) 
                    {
                        delete the_ptr;
                        the_ptr = p;
                        return *this;
                    } 
                    
                    CBPtr"<"T> & operator =(const CBPtr"<"T> &rhs)
                    {
                        if(the_ptr != rhs.the_ptr)
                        {
                            delete the_ptr;
                            the_ptr = rhs.isNull ? 0 : new T(*rhs.the_ptr);
                        }
                        return (*this);
                    } 
                    
                    T &operator *() const { return *the_ptr; }
                    
                    bool isNull() const { return the_ptr == nullptr; }

                    T *releaseControl()
                    {
                        T *save_ptr = the_ptr;
                        the_ptr = 0;
                        return save_ptr;
                    }

                    freind bool operator ==(const CBPtr"<"T> &lhs, const CBPtr"<"T> &rhs)
                    {
                        return this.the_ptr == rhs.the_ptr;
                    }

                    freind bool operator !=(const CBPtr"<"T> &lhs, const CBPtr"<"T> &rhs)
                    {
                        return !(this.the_ptr == rhs.the_ptr);
                    }

                protected:
                    T* the_ptr

                // THIS POINTER CLASS IS FOR BUILT-IN OBJECTS!
            }
        </pre>   
        
        <h3>Benefits:</h3>
        <ol>
            <li>We establish a one-to-one relationship between the ptr and the object</li>
            <li>Automatic copy made when the C++ generated copy constructor is built, since it call the CBPtr's copy constructor</li>
            <li>Our delete will automatically take care of memory - no garbage</li>
            <li>The assignment operator will create a new heap object</li>
            <li>Overloaded the * operator for access to the object</li>
            <li>A test for a null ptr</li>
            <li>Overloads of == and !=</li>
        </ol>

        <h2>... for objects of non-primative type</h2>
        <pre class='brush: cpp'>
            // constructors, destructor, and assignment operators are not inherited
            class COPtr : public CBPtr
            {
                public: 
                
                    COPtr() : CBPtr"<"T>() {}
                    
                    COPtr(const COPtr"<"T> &src) : COPtr"<"T>(src) {}
                    
                    COPtr(T *just_newed) : COPtr"<"T>(just_newed) {}

                    COPtr"<"T> &operator = (T *rhs)
                    {
                        CBPtr"<"T>::operator=(rhs); return (*this);
                    }

                    COPtr"<"T> &operator=(const COPtr"<"T> &rhs)
                    {
                        CBPtr"<"T>::operator=(rhs); return (*this);
                    }

                    T *operator->() const { return the_ptr; }
            };
        </pre>

        <h3>Note:</h3>
        <p>The CBPtr class is for built-in ptrs and should <b>not</b> have the member access operator (->) defined. 
           The COPtr class does and should. It should return either a built in ptr to the class object or an 
           object of a ptr-like class with an overload of the -> operator.</p>
        
        <h3>Example:</h3>
        <pre class='brush: cpp'>
            class Leaker
            {
                public:
                    Leaker(int size) : ptr(new float(0)), Array(size) {}
                    
                    Leaker(const Leaker &src): ptr(new float(*src.ptr)), Array(src.size) {}

                    Leaker &operator-(const Leaker &src) 
                    {
                        p = new float(*src.ptr);
                        array = src.array;
                        return (*this);
                    }

                    ~Leaker() { delete ptr; }

                private:
                    float *ptr;
                    Array"<"int> array;
            };

            void test_function() 
            {
                Leaker leak(-1);
                // .... 
            }

            // So, when f is called, we create (attempt) a leaker object passing(-1)
            // for the site of the array. The float is allocated.

            // Then we try to create the Array witha negative size. It throws an exception.

            // All <b>fully-constructed</b> objects are deallocated. But the leaker object 
            // is not fully constructed and so we have a leak.
        </pre>

        <h2>Now, lets rewrite the Leaker class</h2>
        <pre class='brush: cpp'>
            class NonLeaker
            {
                public:
                    NonLeaker(const int size) : ptr(new float(0)), array(size) {}
                
                private:
                    CBPtr"<"float> p;   // No leakage because this is a fully constructed object, way cool!
                    Array"<"int> array;
            }
        </pre>
    </div>