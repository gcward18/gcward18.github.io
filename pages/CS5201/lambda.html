<!-- Latest compiled and minified CSS -->
<head>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
    <link href="css/shCore.css" rel="stylesheet" type="text/css" />
    <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../css/classes.css">
</head>
<div class="jumbotron text-center">
        <h1>Lambda Functions</h1>
</div>

<body>
    <ul>
        <li>Anonymous functions</li>
        <li>Easy way to make a functior class/object easily.</li>
        <li>Name comes from lambda calculus &lambda; </li>
    </ul>

    <h2>Syntax</h2>

<pre  class='brush: cpp'>
auto func = [] () ->int {};
// auto : auto is required
// func : Name
// [] : capture clause
// () : parameter list
// ->int : optional return type
// {} : body 
</pre>   
    <h3>example:</h3>
<pre  class='brush: cpp'>
auto print_it = [] (int x) { cout &lt;&lt; x &lt;&lt; endl; };
print_it(5);
</pre>
        <h2>Capture Clause</h2>
<pre  class='brush: cpp'>
int x = 3;

auto times_x = [=] (int n) {
    retun n * x;
};
// [=] : capturing by value
</pre>

    <h2>Functor Class</h2>
<pre  class='brush: cpp'>
class TimesX{
    public:
        TimesX(int x) : x() {}
        int operator() (int n) {
            return n*x;
        }
    private:
        int x;
};
</pre>
    <p>
        The functor class and Capture clause are equivalent
    </p>

    <h2>Capture Clauses</h2>
    <ul>
        <li>By value/copy : =</li>
        <li>By reference : &</li>
        <li>calling object by ref : this ; by value : *this</li>
    </ul>
<pre  class='brush: cpp'>
[a,b,&r,m=move(m)]
</pre>

    <h2>Why are Lambdas cool?</h2>
    <ul>
        <li>Shorthand makes code more legible</li>
        <li>"Glue" functions together that don't quite fit</li>
        <li>Make library code more flexible</li>
    </ul>

    <h2>stdlib Features</h2>
    <ul>
        <li>std::transform </li>
<pre  class='brush: cpp'>
vector&lt;int> in = { 1, 2, 3, 4, .. , 7};
vector&lt;int> out;
std::transform( in.begin(), // start
                in.end(),   // stop
                out.begin(),// store values
                [](intx) { return x*2; }
              );
</pre>
    </ul>

<h3>Function Pointer example</h3>
<pre  class='brush: cpp'>
int double(int x) {
    return x*2;
}
vector&lt;int> in = { 1, 2, 3, 4, .. , 7};
vector&lt;int> out;
std::transform( in.begin(), // start
                in.end(),   // stop
                out.begin(),// store values
                &double
              );
</pre>


<h3>Another example</h3>
<p>
in &lt;numeric>
std::accumulate
<ul>
    <li>Structure (vector)</li>
    <li>Start value</li>
    <li>Combine element& start<br/>
        [ ](int l, int r){<br/>
            return l+r;<br/>
        }<br/></li>
</ul>
</p>

    <h2>Storing things you can call</h2>
    <h3>std::function</h3>
<pre  class='brush: cpp'>
std::function&lt;string(int,int)> f = 
    [ ] (int, int) { ..... };
</pre>


<h3>Better typedef</h3>
<pre  class='brush: cpp'>
// using alias = type;

using input_callback = std::function&lt;void(EventDispatcher&, const string&)>;
</pre>

</body>