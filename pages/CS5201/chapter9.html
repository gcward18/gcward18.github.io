<!-- Latest compiled and minified CSS -->
<head>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
    <link href="css/shCore.css" rel="stylesheet" type="text/css" />
    <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../css/classes.css">
</head>
<div class="jumbotron text-center">
        <h1>Commonality of Behavior</h1></div>

<div class="copy_swap">
    <div name="slide">
        <p>So, one of the great advantages to C++ is its Object-Oriented Nature. One of the big motivation of this course is to <br/>
        show how we can take advantate of the OOParadigm to write code that is more adaptable and extendable. <br/><br/>


        Up til now, we have seen how encapsulation allows us to bundle together data and functionality to create code that more adequately <br/>
        describes the real world.<br/>

        <br/> Class can then dictate how modeling objects behave we expand our abstractions by indroducing inheritance- where we can model <br/>
        the idiom ""is usable as". We're going to intoduce base classes and virtual functions.

        <br/><br/>
        We are going to use a running model provided by the authors Barton & Nackman.<br/><br/>
    </p>

    <h3>The General Purpose Interface Bus (GPIB)</h3>
    <p>GPIB_Contoller is a bus that you can plug things into</p>
<b>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
class GPIB_Contoller
{
    public:
        void insert(char *device_name, int address);
        void send(int address, float value);
        void send(int address, char *command);
        float recieve(int address);
};

class Acme130
{
    public:
        Acme130(GPIB_Contoller &cont, int address);
        void set(float voltage);
        float min();
        float max(); 
    private:
        GPIB_Contoller my_cont;
        int gpib_address;
};

Acme130::Acme130(GPIB_Contoller &cont, int address)
{
    my_cont = cont;
    gpib_address = address;
    my_cont.insert("Acme130", gpib_address);
}


class Volt_Metric
{
    public:
        VoltageMetric();
        void read();
    private:
        GPIB_Contoller controller;
        int address;
};

class Calibrate
{

};
</pre>
</b>

    <p>Consider the similarities between a model andthe reality it represents. The real system has <b>behavior</b> and <b>state</b>.<br/>
    "Behavior" is what that system has potential to do and "state" is the measure of its being at any instance. <br/><br/>

    Well, C++ objects/classes also have behavior and state. State is given by member variables, behavior is dictated by <br/>
    its member functions, and behavior dictates or is dictated by the state of the object. <br/><br/>

    Notice that the GPIB_Contoller has no state. It is a class that represents behvaior only. <br/><br/>

    The gola of encasulation is to hide information. What info? How? Certainly we hide data in the private section to protect it<br/>
    from being modified or accessed in any way that we do not wish. But we also hide implementation by not exposing data structures<br/>
    <br/>

    (e.x. iterators)  But we can also hide implementation by using vague "terms" - named objects that are realy names of categories<br/>
    <br/>

    We will now introduce our first base class.
    <br/><br/>
    We also have another voltae supply called the VoltOn59
</p>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
class VoltOn59
{
    // stuff....
};
</pre>
</b>
    <p>
        Know that we have multiple voltage supplies, we can generalize (the Acme130 and VoltOn59) to "VoltageSupply".<br/>
        This is because we really don't care about the details... of state representation. The functionality is key,<br/>
        but how it works who cares as long as it works.<br/>
    </p>
        <h3>Interface</h3>
    <p>We need to add 2 components to the picture.<br/>
        One is the VoltyMetrics voltage meter.
    </p>
</p>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
class VoltyMetrics
{
    public:
        VoltyMetrics(GPIB_Contoller &controller, int what_address);
        float read() { return my_controller.recieve(address); }
    private:
        GPIB_Contoller my_controller;
        int address;    
};
</pre>
</b>

    <p>
        And now we add calibrate() which is used to calibrate the voltage supply using the meter.
    </p>
</p>
<b>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
float calibrate(Acme130 &supply, VoltyMetrics &meter, float test_voltage)
{
    supply.set(test_voltage);
    return std::abs(test_voltage-meter * test_voltage);
};
</pre>
</b>
    <p>
        So, we put the system all together and it works great!<br/>
        But then... updates ... no, really the volate supply burns up -"shoots craps"<br/>
        So, you go down the the hall and borrow Tanner's VoltOn59 to use. That's fine int <br/>
        in the real system, but not here! Not the calibrate() has as a parameter an Acme130, not VoltOn59.<br/>
        But we will make it work, we now make our first inface base. <br/><br/>

        W.O.W (Words of Wisdom) :<br/>
        Separating the code that specifies the implementation of objects from code that uses the objects and so allows<br/>
        code to access only behavior (functions) and not state representation (data structures and member variables) <br/>
        gives us code that is adaptable and versitile. implementation can change while interface remains the same because<br/>
        the user doesn't need to know details. 
    </p>
<b>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
class VoltageSupply
{
    public:
        virtual void set(float volts) = 0;
        virtual float min() const = 0;
        virtual float max() const = 0;
        virtual ~VoltageSupply() {};
};
</pre>
</b>
    <p>
        <br/>
        <br/>
        The functions ending = 0 are pure virtual functions. No instances of any class having pure virutal functions <br/>
        can be create. This class is called an (interface)<b> based class</b>. Usually, interface bases have pure <br/>
        virtual functions and no state (variables). The term "interface base" is not a C++ term. It's a design term.<br/>
        We put Commonality of behavior in interface bases. Now we have to change the calibrate function. 
    </p>
<b>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
float calibrate(VoltageSupply &supply, ....);

// and then the Acme 130 ( and the VoltOn59)

class Acme130: public VoltageSupply
{
    public:
        Acme130( _ );
        virtual void set( _ );
        virtual float min() const;
        virtual float max() const;
    private:
        GPIB_Contoller my_controller;
        int my_address;
}
</pre>
</b>
<p>
    So now the Acme130 "is usable as" a VoltageSupply. We do the same for VoltOn59. <br/>
    <br/>
    The "Acme130: public VoltageSupply" sys that the Acme is a VoltageSupply and can be used as a voltage supply <br/>
    through references and pointers to VoltageSupply.<br/>

    <h3>Notes</h3>
    <ul>
        <li>The "virtual" designation in the derived classes is not necessary do it for clarity</li>
        <li>All aspects of the functions must be identical from base to derived class</li>
        <li>The definitions of the functions do not need to change just because the are now virtual</li>
        <li>Interface bases have no state (no member variables)</li>
        <li>Interface bases have no constructors</li>
        <li>In an interface base class, any function that is defined there needs to be defined in terms of common functionality<br/>
            across all derived classes</li>
        <li>The term "abstract base" has atleast one pure virtual function</li>
        <li>Use interface bases... and use an abstract base class as the interface. In this way, the compiler can help you<br/>
            by flagging an error if you have forgotten to implment a function in some derived class.</li>
    </ul>
</p>

    <h3>So....</h3>
    <p>
        Any class can be derived from two interfaces. Lets write a GPIBInstrument interface base to represent any kind of<br/> 
        GPIB instrument
    </p>
    <b>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
class GPIBInstrument
{
    public:
        virtual void send(const char*) =0;
        virtual void send(fload f) =0;
        virtual float recieve() =0;
        virtual ~GPIBInstrument(){}
};
</pre>
</b>
    <p>
        This is an interface for a generalized GPIB instrument So, the Acme130 and the VoltOn59 are two such devices.<br/>
        They can be made "usable as" GPIBInstruments. 
    </p>
    <b>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
class Acme130: public VoltageSupply, public GPIBInstrument
{
    public:
        Acme130();

        // VS interface
        virtual void set(_) =0;
        .
        . 
        . 

        // GPIB interface
        virtual void send(_);
        . 
        . 
        . 

    private:
};
</pre>
</b>

    <p>It's important to note that the addition of the derivation from the second base doesn't change how the <br/>
        Acme130 behaves as a VS in any client code such as the calibrate() function. The device can be VS <br/>
        independent of being a GPIBInstrument. Ith doesn't need any recoding. The interfaces are independent. <br/>
        <br/>   
    </p>
    <h3>Section 9.8</h3>
    <p>
        So far, we have seen that a client function such as the calibrate() function can be passed an object <br/>
        through a reference or ptr. to an interface base. But we can also have an interface base as member types <br/>
        in classes. But if so it has to be a reference or a ptr (to the type).<br/><br/>

        Lets generalize the GPIB_Contoller to an interface - to represent any such kind of GPIB thing.
    </p>
    <b>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
class GPIB_Contoller
{
    public:
        virtual void insert(__) = 0;
        virtual void send(__) = 0;
        virtual void send(__, __) = 0;
        virtual float recieve() =0;
        virtual ~GPIB_Contoller(){}
};

// Now, we change the original GPIB_Contoller

class GPIB: public GPIB_Contoller
{
    public: 
        virtual void insert(__);
        virtual void send(__); 
        virtual void send(__, __);
};
</pre>
</b>
    <p>
        It's same as before execept now derive from the master class of such controllers. Now we generalize <br/>
        the voltage supplies.
    </p>
<b>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
class Acme130: public VoltageSupply, public GPIBInstrument
{
    public:
        Acme130(GPIB_Contoller &controller, ...);
        // etc.
    private:
        GPIB_Contoller &my_controller; // &lArr; Important
        int my_address;
};
</pre>
</b>
    <p>
        The constructor initializes the reference data member. That GPIB_Contoller can be any kind of such device<br/>
        As another example, lets create a voltage/current test class.
    </p>
<b>
<pre  class='brush: cpp' style="padding: 2%; width:500px; height: 30%; margin-left: 5%;">
class IVtester
{
    public:
        // notice parameters are references and member variables are references
        IVtester(VoltageSupply &vs, VoltageMetric &vm) : supply(vs), meter(vm) {}
        double current(_doStuff);
    private:
        VoltageSupply &supply;
        VoltageMetric &meter;
};
</pre>
</b>
    <p>
        So, we can create an object of type IVtester with any pairing of voltages supply and meter. The member <br/>
        function, current() operates dependent on the functionaility of the specific "values" of VoltageSupply and Meter.<br/>
        <br/>

        <h3>9.9</h3>
        Is it possible to have an array of interfaces? The answer is yes and it's appropriate in the case of this <br/>
        model. And in this example (rather complex) in 9.9 shows that. 
    </p>
</div>