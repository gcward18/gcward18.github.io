<!-- Latest compiled and minified CSS -->
<head>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
    <link href="css/shCore.css" rel="stylesheet" type="text/css" />
    <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../css/classes.css">
</head>
<div class="jumbotron text-center">
        <h1>Commonality of Implementation</h1>
</div>
<body>
    <p>
        In Chapter 9 we focused on common behavior. And the concept of an interface base. <br/>
        Virtual function and no state variables characterized the base class; derived classes had<br/>
        common behavior but differing Implementations.<br/>
        <br/>
        Now, our current goal is to address the issue of repetition of code. We are going to do <br/>
        this by using public derivation for extension. In chapter 4 we had a simple array class and then<br/>
        rewrote it as a checkArray class to be able to include exception handling for certain operations<br/>
        but doing it that way leads to code repetition/replication, can we do it better? Of cour the answer<br/>
        is yes. We are going to do the same thing but now using inhertance.


<pre  class='brush: cpp'>
// Note: the reserved word "public"
// means that it's a public base

// Notice also that we have no Virtual
// functions and we could have, but in 
// this case don't have state variables.
// So, this is not an interface base;
class CheckedArray: public Array 
{
    public:
        checkArray();
        checkArray(const int n);
        float& operator[](const int i);
        checkArray& operator=(const float f);
        class SubscriptErr{};

};


// The array class is an Implementation base
class Array
{
    public:
        Array();
        Array(int n);
        Array(const Array& a);
        ~Array();
        float& operator[](const int i);
        Array& operator=(float f);
        Array& operator=(const Array& s);
        int numElements() const;

    private:
        int num_elements;
        float* ptr;
        void copy(const Array& src);
};

// unless otherwise defined by the derived class, constructors,
// destructors and assignment operators are automaticlly built
// by C++. If you want them different, you need to make them
// yourself. Every derived class will need to build two things
// the base subobject and its own state variables. 
</pre> 

        Any instance of a derived class contains an instace of a <b>base subobject</b><br/>
        Now, each of member of the base is not inherited by the derived class except<br/>
        <ul>
            <li>constructors</li>
            <li>assignment operators</li>
            <li>destructors</li>
        </ul>

        Any function that is declared in the derived class that has the same identifier <br/>
        as one in the parent class is said to "hide" the base version.<br/><br/>

        Thus, CheckedArray has its own operator[] defined, and its own operator= <br/>
        along with constructors. The base class definitions in the derived class definitions<br/>
        to save code.<br/><br/>

      
<pre  class='brush: cpp'>
float& CheckedArray::operator[](const int i){
    if(i&lt;0 || i&ge;numElements()) throw SubscriptErr();
    return Array::operator[](i);
}

//                                       base class initializer
CheckedArray::CheckedArray(const int n):     Array(n) {}

</pre>   
        Derived class constructors should have base initializers for every base. <br/>
        If no base initializers are supplied, then C++ calls the base class default<br/>
        constructor. Base class initializers should be called/invoked in the order <br/>
        they are declared. <br/>
        <br/>

        It's best to provide a default constructor for 2 reasons.
        <ul>
            <li>if you write any other constructor, then c++ supresses the auto<br/>
            generation of the default</li>
            <li>To create an array of these objects you need a default</li>
        </ul>

        <br/>
        If c++ generates it's own copy constructor, own copy assignment, then they<br/>
        are going to call the base class version.

             
<pre  class='brush: cpp'>
CheckedArray& checkArray::operator =(float f)
{
    Array::operator =(f);
    return (*this);
}
</pre> 
    </p>

    <h2>Client code</h2>
    <p>
        Derived class objects can be passed into functions through pointers or references to base class <br/>
        parameters. If so, the base class operations will apply    <br/>

    </p>
        <h3>suppose</h3>       
<pre  class='brush: cpp'>
float maxelt(Array& a){
    float max = a[0];
    for(int i = 0; i&lt; a.numElements; i++)
    {
        if(a[i] > max)
            max[i];
    }
    return max;
}
</pre> 
    <p>
        <h3>Question</h3>
        which [] operator applies here? Is the index checked? Ans. No. Because this is a reference to an <br/>
        Array object, not a CheckedArray.
    </p>

    <h2>What about interface base classes and extension by public derivation?</h2>
    <p>
        The Acme Corp. Decides to build another more advanced voltage supply - the Acme140
    </p>
<pre  class='brush: cpp'>
class Acme140: public Acme 130
{
    public:
        enum Jumper { J1, J2 };
        Acme140(GPIBController& controller, int address, Jumper j);
        virtual float max() const;
    private:
        float max_volts;
};
</pre> 
    <p>
        So, the 140 inherits everything from the 130 but also allows for a max voltage, that is going <br/>
        to be determined by the j-value. So, the 140 "is a" 130 "is a" VoltageSupply, and "is a" GPIBInstrument<br/>
        <br/>

        But note that the Acme130 is an <b>Implementation base</b>, not an interface base. So, we have to have a<br/>
        constructor for the 140:
    </p>
<pre  class='brush: cpp'>
Acme140::Acme140(GPIBController controller, int address, Jumper j):
         Acme140(controller, address), 
         max_volts(j==J1 ? 10: 50)
         {}
</pre> 
    <p>
        Here, the Acme140 constructor calls the base subobjects constructor and then initializes it own member(max_volts);<br/>
        And, we also need to provide the new max() function for Acme140... Because we want it to behave like a 140<br/>
    </p>
<pre  class='brush: cpp'>
Acme140::max() const 
{
    return max_volts;
}
</pre> 
    <p>
        *Deviced class defined virtual functions override the base class functions.
    </p>
<pre  class='brush: cpp'>
Acme140 supply(gpib, 15, Acme140::J2);
cout &lt;&lt; supply.max();  // --> 50

Acme130& as_130 = supply;
cout &lt;&lt; as_130.max(); // --> 50

VoltageSupply& as_VS = supply;
cout &lt;&lt; as_VS.max(); // --> 50
</pre> 
    <p>
        Why 50 in ex. case? The max() function is virtual. This gives us trup object oriented behavior
    </p>

    <h3>Consider</h3>
<pre  class='brush: cpp'>
void Acme130::set(float v)
{
    if(v > max() || v &lt; min()) throw exception();
    send(v);
}
// Since the Acme 140 derives from the Acme 130 and the max 
// function is virtual, the correct max() is called here... 
// That of the object 

// ex(cont.) 
supply.set(20); // works
as_130.set(20); // works

Acme130 s(gpib, int, Acme140::J1);

s.set(20); // throws exception
</pre> 

    <h2>Section 3</h2>
    <p>
    <ol>
        <li>
            Theere are problems stemming from public inheritance. We expose design decision when using extension <br/>
            by public inhertance. You've exposed that you are implemnting in a Implementation base. It's always<br/>
            a trade-off between the ease of this design and the likelyhood of any change in Implementatio. But<br/>
            in general, we want to hide any implementation decision if possible
        </li>
        <li>
            We are foreced to use virtaul functions. If we want true OO behavior, then virtual functions are a <br/>
            must. If the virtual max() was not virtual, then using an object via a ptr or ref to a base type <br/>
            would not give you the expected behavior. Calling max() for a 140 obj. "as a" 130, would give you <br/>
            the max voltage of the 130 type not the 140. The virtual function overhead is expensive, but public<br/>
            inhertance for extension forces us to use it... if we don't want schizophrenic function behavior. <br/>
            Thus, avoid new definitons of function in derived classes if they're non-virtual. <br/><br/>

            Should we necessarily use virtual functions?
            <ol>
                <li>When making a "concrete" class - one that is not likely to change</li>
                <li>Sometimes you simply wnat continuity from base to derviced class</li>
            </ol>

            <h3>Consider:</h3>
<pre  class='brush: cpp'>
void printmax(Acme130 a){
    cout &lt;&lt; "Max Voltage is " &lt;&lt; a.max();
}
</pre> 
            and we have 2 supplies, supply1 and supply2, both of type Acme140 with supply1 having max of 10 and <br/>
            supply2 having a max of 50, then printmax(supply1) -> 10 and printmax(supply2) -> 10  <br/> <br/>

            This is because the parameter for the function is an Acme130. So, it's the base subobject that is copied<br/>
            so the max is that of an Acme130. THe 130 is both <b>interface</b> and <b>implementation</b> base. The <br/>
            compiler can't catch the "mistake".<br/>
            <br/>

            If, on the otherhand, we had used a reference to the voltage supply interface base (because they are Voltage Supplies)<br/>
            then the compiler would have caught it.<br/>
            => use interfaces!<br/>
     
        </li>
    </ol>

    <h2>Member Function Forwarding</h2>
<pre  class='brush: cpp'>
class Acme130: public VoltageSupply, public GPIBInstrument
{
    public:
        Acme130(GPIBController gpib, int n);
        // VS interface
        //..
        // GPIBInstrument interface
        virtual void send(const char* c);
        virtual void send(float v);
        virtual float recieve();
    private:
        GPIBController& my_controller;
        int my_address;
};

// VoltOn59 is the same
</pre>   

    Furthermore, the VoltyMetrics inherits from a GPIBInstrument base also. All 3 of these have a GPIBInstrument base adn have<br/>
    the same functionality and data and usi it in the same way. <br/>
    <br/>

    We can avoid the replication of code by using member function forwarding. We create a new class:

<pre  class='brush: cpp'>
class GPIBInstrumentData
{
    public:
        GPIBInstrumentData(GPIBController& c, int address, const char* name);
        // Instrument interface
        void send(__);
        void send(__);
        void recieve(__);
    private:
        GPIBController& controller;
        int my_address;
    
};
</pre> 
    Structurally like the 130, 59, VoltyMetric.., but not like the interface.<br/>
    The function implementations are the same. But now we require only one copy example....

<pre  class='brush: cpp'>
void GPIBInstrumentData::send(float v){
    my_control.send(my_addr, v);
}
</pre>
    And this is going to work for all such GPIB instruments. The constructor initalizes the data and <br/>
    inserts the device into the controller Since it isn't a part of a specific device, it needs that<br/>
     additional parameter. The device name.


<pre  class='brush: cpp'>
GPIBInstrumentData::GPIBInstrumentData(GPIBController controller, int address, char* name) : my_controller(c), my_address(address)
{
    my_controller.insert(name, this->my_address);
}
</pre>

<pre  class='brush: cpp'>
class Acme130: public VS, public GPIBInstrument
{
    public:
        Acme130(GPIBController& c, int address): gpib_rep(c, address, "Acme130"){}
        // Voltage supply interface
        //   ....
        // Instrument interface
        virtual void send(const char* cmd) {
            gpib_rep.send(cmd);
        }
        virtual void send(const float f) {
            gpib_rep.send(f);
        }
        virtaul float recieve() {
            return gpib_rep.recieve();
        }
    private:
        GPIBInstrumentData gpib_rep;
};
</pre>

<pre  class='brush: cpp'>
                        -----------------
                        | GPIBInstrument|
                        _________________
                        |               |
                        |               |
                        -----------------
                     ^          ^          ^
                    /           |           \
    ----------------    -----------------   ----------------
    | VoltyMetrics |    |    Acme130    |   |   VoltOn59   |
    ----------------    -----------------   ----------------
    |              |    |               |   |              |
    |              |    |               |   |              |
    ----------------    -----------------   ----------------
                    \           |           /
                     V          V          V
                        --------------------
                        |GPIBInstrumentData|
                        --------------------
                        |                  |
                        |                  |
                        --------------------
</pre>
</p>

</body>