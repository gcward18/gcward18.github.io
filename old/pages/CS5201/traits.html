<!-- Latest compiled and minified CSS -->
<head>
    <link href="css/shCore.css" rel="stylesheet" type="text/css" />
    <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
</head>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
<div class="jumbotron text-center">
        <h1>Traits Classes</h1>
</div>

<body>
    <p>
        With traits classes you can create a mapping of the names that could be <br/>
        very useful with return-type problems. <br/>
        <br/>

        Supposed you're writing a library of classes for mathy-type problems. Perhaps<br/>
        you template on different numerical types. Each of your standard types have <br/>
        constants associated with them, such as FLT_MAX_EXP and DBL_MAX_EXP and you <br/>
        have different size mantissas and epsilons, etc.<br/><br/>

        If you template on these numeric types and need to refer to these constant <br/>
        in the code, the compiler has no way to understand which you want. Here's a <br/>
        traits class solution.

<pre class="brush: cpp">
template &lt;class numT>
struct float_traits {};

struct float_traits&lt;float>
{
    typedef float float_type;
    enum {max_exponent = FLT_MAX_EXP};
    static inline float_type epsilon() { return FLT_EPSILON;}
    //....
}

struct float_traits&lt;double>
{
    typedef double float_type;
    enum {max_exponent = DBL_MAX_EXP};
    static inline float_type epsilon() { return DBL_EPSION;}
}

//... and so on
</pre>
    <h2>Example 1:</h2>
        So, when refering to max_exponent w/o knowing the type intened, <br/>
        we do not have any worries. For instance, if we have:
<pre class="brush: cpp">
template &lt;class numT>
class Matrix
{
    public: 
        typedef numT num_type;
        typedef float_traits&lt;num_type> traits_type;
        inline num_type epsilon() { return traits_type::epsilon; }
        //....
};
</pre>
    <h2>Example 2:</h2>
<pre class="brush: cpp">
template &lt;class T>
T average(const T* data, const int n)
{
    T sum = 0;
    for(int i = 0; i < n; i++} sum += data[i];
    return sum/n;
}
</pre>
        This is a templated func that computes and returns the average of an <br/>
        arry of T_Things. IF a arry of ints, it returns an int average; float <br/>
        returns a float average etc.

<pre class="brush: cpp">
template &lt;class>
struct float_trait { typedef T T_float;}

template &lt;>
struct float_trait&lt;char>
{
    typedef double T_float;
};

template &lt;>
struct float_trait&lt;int>
{
    typedef double T_float;
};
// so on and so on
</pre>
        So, what you map from is the template parmeter, and to goes inside the<br/>
        struct. Then:
<pre class="brush: cpp">
float_trait&lt;T>::T_float;
</pre>
        will end up as the appropriate type. Now average() is written as 
<pre class="brush: cpp">
template &lt;class T>
typename float_trait&lt;T>::T_float average(const T* data,
                                            cosnt int n)
{
    for(------) ......;
    return sum/n;
}
</pre>

    <h2>Example 3 : Type Promotion</h2>
<pre class="brush: cpp">
template &lt;class T1, class T2>
Vector&lt;???> operator + (Vector&lt;&a, Vector&lt;T2>& b);
</pre>

        We would expect our return type template parameter to somehow reflect<br/>
        the vectors that are passed. How?
<pre class="brush: cpp">
template&lt;class T1, class T2>
struct promote_trait{};

#define DECLARE_PROMOTE(A,B,C)                   \
template&lt;> struct promote_traits&lt;A,B>     \
{                                               \
    typedef C T_promote                         \
};

DECLARE_PROMOTE(int, char, int);
DECLARE_PROMOTE(int, float, float);
DECLARE_PROMOTE(float, double, double);
//etc

// to use .... 
template&lt;class T1, class T2>
Vector&lt; typename promote_trait&lt;T1, T2>::T_promote> operator (Vector&lt;T1>& a, Vector&lt;T2>& b);
</pre>
    </p>
</body>
